using BACnetDataTypes;
using BACnetDataTypes.Constructed;
using BACnetNetwork.Enums;
using BACnetServices.Service.Confirmed;

namespace BACnetServices.APDU
{
    public class ConfirmedRequest : APDU, ISegmentable
    {
        public static readonly byte TYPE_ID = 0;

        public static int GetHeaderSize(bool segmented)
        {
            if (segmented)
                return 6;
            return 4;
        }

        /**
         * This parameter indicates whether or not the confirmed service request is entirely, or only partially, contained
         * in the present PDU. If the request is present in its entirety, the value of the 'segmented-message' parameter
         * shall be FALSE. If the present PDU contains only a segment of the request, this parameter shall be TRUE.
         */

        /**
         * This parameter is only meaningful if the 'segmented-message' parameter is TRUE. If 'segmented-message' is TRUE,
         * then the 'more-follows' parameter shall be TRUE for all segments comprising the confirmed service request except
         * for the last and shall be FALSE for the readonly segment. If 'segmented-message' is FALSE, then 'more-follows' shall
         * be set FALSE by the encoder and shall be ignored by the decoder.
         */

        /**
         * This parameter shall be TRUE if the device issuing the confirmed request will accept a segmented complex
         * acknowledgment as a response. It shall be FALSE otherwise. This parameter is included in the confirmed request so
         * that the responding device may determine how to convey its response.
         */

        /**
         * This optional parameter specifies the maximum number of segments that the device will accept. This parameter is
         * included in the confirmed request so that the responding device may determine how to convey its response. The
         * parameter shall be encoded as follows: B'000' Unspecified number of segments accepted. B'001' 2 segments
         * accepted. B'010' 4 segments accepted. B'011' 8 segments accepted. B'100' 16 segments accepted. B'101' 32 segments
         * accepted. B'110' 64 segments accepted. B'111' Greater than 64 segments accepted.
         */

        /**
         * This parameter specifies the maximum size of a single APDU that the issuing device will accept. This parameter is
         * included in the confirmed request so that the responding device may determine how to convey its response. The
         * parameter shall be encoded as follows: B'0000' Up to MinimumMessageSize (50 octets) B'0001' Up to 128 octets
         * B'0010' Up to 206 octets (fits in a LonTalk frame) B'0011' Up to 480 octets (fits in an ARCNET frame) B'0100' Up
         * to 1024 octets B'0101' Up to 1476 octets (fits in an ISO 8802-3 frame) B'0110' reserved by ASHRAE B'0111'
         * reserved by ASHRAE B'1000' reserved by ASHRAE B'1001' reserved by ASHRAE B'1010' reserved by ASHRAE B'1011'
         * reserved by ASHRAE B'1100' reserved by ASHRAE B'1101' reserved by ASHRAE B'1110' reserved by ASHRAE B'1111'
         * reserved by ASHRAE
         */

        /**
         * This parameter shall be an integer in the range 0 - 255 assigned by the service requester. It shall be used to
         * associate the response to a confirmed service request with the original request. In the absence of any error, the
         * 'invokeID' shall be returned by the service provider in a BACnet-SimpleACK-PDU or a BACnet-ComplexACK-PDU. In the
         * event of an error condition, the 'invokeID' shall be returned by the service provider in a BACnet-Error-PDU,
         * BACnet-Reject-PDU, or BACnet-Abort-PDU as appropriate.
         * 
         * The 'invokeID' shall be generated by the device issuing the service request. It shall be unique for all
         * outstanding confirmed request APDUs generated by the device. The same 'invokeID' shall be used for all segments
         * of a segmented service request. Once an 'invokeID' has been assigned to an APDU, it shall be maintained within
         * the device until either a response APDU is received with the same 'invokeID' or a no response timer expires (see
         * 5.3). In either case, the 'invokeID' value shall then be released for reassignment. The algorithm used to pick a
         * value out of the set of unused values is a local matter. The storage mechanism for maintaining the used
         * 'invokeID' values within the requesting and responding devices is also a local matter. The requesting device may
         * use a single 'invokeID' space for all its confirmed APDUs or multiple 'invokeID' spaces (one per destination
         * device address) as desired. Since the 'invokeID' values are only source-device-unique, the responding device
         * shall maintain the 'invokeID' as well as the requesting device address until a response has been sent. The
         * responding device may discard the 'invokeID' information after a response has been sent.
         */

        /**
         * This optional parameter is only present if the 'segmented-message' parameter is TRUE. In this case, the
         * 'sequence-number' shall be a sequentially incremented unsigned integer, modulo 256, which identifies each segment
         * of a segmented request. The value of the received 'sequence-number' is used by the responder to acknowledge the
         * receipt of one or more segments of a segmented request. The 'sequence-number' of the first segment of a segmented
         * request shall be zero.
         */

        /**
         * This optional parameter is only present if the 'segmented-message' parameter is TRUE. In this case, the
         * 'proposed-windowsize' parameter shall specify as an unsigned binary integer the maximum number of message
         * segments containing 'invokeID' the sender is able or willing to send before waiting for a segment acknowledgment
         * PDU (see 5.2 and 5.3). The value of the 'proposed-window-size' shall be in the range 1 - 127.
         */

        /**
         * This parameter shall contain the parameters of the specific service that is being requested, encoded according to
         * the rules of 20.2. These parameters are defined in the individual service descriptions in this standard and are
         * represented in Clause 21 in accordance with the rules of ASN.1.
         */
        private byte serviceChoice;

        /**
         * This field is used to allow parsing of only the APDU so that those fields are available in case there is a
         * problem parsing the service request.
         */

        public ConfirmedRequest(bool segmentedMessage, bool moreFollows, bool segmentedResponseAccepted,
            MaxSegments maxSegmentsAccepted, MaxApduLength maxApduLengthAccepted, byte invokeId, int sequenceNumber,
            int proposedWindowSize, ConfirmedRequestService serviceRequest)
        {
            setFields(segmentedMessage, moreFollows, segmentedResponseAccepted, maxSegmentsAccepted,
                maxApduLengthAccepted,
                invokeId, sequenceNumber, proposedWindowSize, serviceRequest.ChoiceId);

            ServiceRequest = serviceRequest;
        }

        public ConfirmedRequest(bool segmentedMessage, bool moreFollows, bool segmentedResponseAccepted,
            MaxSegments maxSegmentsAccepted, MaxApduLength maxApduLengthAccepted, byte invokeId, int sequenceNumber,
            int proposedWindowSize, byte serviceChoice, ByteStream serviceData)
        {
            setFields(segmentedMessage, moreFollows, segmentedResponseAccepted, maxSegmentsAccepted,
                maxApduLengthAccepted,
                invokeId, sequenceNumber, proposedWindowSize, serviceChoice);

            ServiceData = serviceData;
        }

        private void setFields(bool segmentedMessage, bool moreFollows, bool segmentedResponseAccepted,
            MaxSegments maxSegmentsAccepted, MaxApduLength maxApduLengthAccepted, byte invokeId, int sequenceNumber,
            int proposedWindowSize, byte serviceChoice)
        {
            IsSegmentedMessage = segmentedMessage;
            IsMoreFollows = moreFollows;
            IsSegmentedResponseAccepted = segmentedResponseAccepted;
            MaxSegmentsAccepted = maxSegmentsAccepted;
            MaxApduLengthAccepted = maxApduLengthAccepted;
            InvokeId = invokeId;
            SequenceNumber = sequenceNumber;
            ProposedWindowSize = proposedWindowSize;
            this.serviceChoice = serviceChoice;
        }


        public override byte PduType => TYPE_ID;


        public byte InvokeId { get; private set; }

        public int SequenceNumber { get; private set; }

        public MaxApduLength MaxApduLengthAccepted { get; private set; }

        public MaxSegments MaxSegmentsAccepted { get; private set; }

        public bool IsMoreFollows { get; private set; }

        public int ProposedWindowSize { get; private set; }

        public bool IsSegmentedMessage { get; private set; }

        public bool IsSegmentedResponseAccepted { get; private set; }

        public ConfirmedRequestService ServiceRequest { get; private set; }

        public void AppendServiceData(ByteStream data)
        {
            ServiceData.Write(data);
        }

        public ByteStream ServiceData { get; private set; }


        public override void write(ByteStream queue)
        {
            queue.WriteByte((byte) (GetShiftedTypeId(TYPE_ID) | (IsSegmentedMessage ? 8 : 0) | (IsMoreFollows ? 4 : 0)
                                    | (IsSegmentedResponseAccepted ? 2 : 0)));
            queue.WriteByte((byte) (((MaxSegmentsAccepted.GetId() & 7) << 4) | (MaxApduLengthAccepted.GetId() & 0xf)));
            queue.WriteByte(InvokeId);
            if (IsSegmentedMessage)
            {
                queue.WriteByte((byte) SequenceNumber);
                queue.WriteByte((byte) ProposedWindowSize);
            }
            queue.WriteByte(serviceChoice);
            if (ServiceRequest != null)
                ServiceRequest.write(queue);
            else
                queue.Write(ServiceData);
        }

        public ConfirmedRequest(ServicesSupported servicesSupported, ByteStream queue)
        {
            byte b = queue.ReadByte();
            IsSegmentedMessage = (b & 8) != 0;
            IsMoreFollows = (b & 4) != 0;
            IsSegmentedResponseAccepted = (b & 2) != 0;

            b = queue.ReadByte();
            MaxSegmentsAccepted = (MaxSegments) ((byte) ((b & 0x70) >> 4));
            MaxApduLengthAccepted = (MaxApduLength) ((byte) (b & 0xf));
            InvokeId = queue.ReadByte();
            if (IsSegmentedMessage)
            {
                SequenceNumber = queue.popU1B();
                ProposedWindowSize = queue.popU1B();
            }
            serviceChoice = queue.ReadByte();
            ServiceData = new ByteStream(queue.ReadToEnd());

            ConfirmedRequestService.checkConfirmedRequestService(servicesSupported, serviceChoice);
        }


        public void ParseServiceData()
        {
            if (ServiceData != null)
            {
                ServiceRequest = ConfirmedRequestService.createConfirmedRequestService(serviceChoice, ServiceData);
                ServiceData = null;
            }
        }


        public APDU clone(bool moreFollows, int sequenceNumber, int actualSegWindow, ByteStream serviceData)
        {
            return new ConfirmedRequest(IsSegmentedMessage, moreFollows, IsSegmentedResponseAccepted,
                MaxSegmentsAccepted, MaxApduLengthAccepted, InvokeId, sequenceNumber, actualSegWindow,
                serviceChoice, serviceData);
        }


        public override string ToString()
        {
            return "ConfirmedRequest(segmentedMessage=" + IsSegmentedMessage + ", moreFollows=" + IsMoreFollows
                   + ", segmentedResponseAccepted=" + IsSegmentedResponseAccepted + ", maxSegmentsAccepted="
                   + MaxSegmentsAccepted + ", maxApduLengthAccepted=" + MaxApduLengthAccepted + ", invokeId=" + InvokeId
                   + ", sequenceNumber=" + SequenceNumber + ", proposedWindowSize=" + ProposedWindowSize
                   + ", serviceChoice=" + serviceChoice + ", serviceRequest=" + ServiceRequest + ")";
        }


        public override bool expectsReply { get; protected set; } = true;
    }
}
